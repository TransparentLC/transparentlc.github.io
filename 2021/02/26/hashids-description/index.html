<!doctype html><html lang="zh-Hans"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no" name="viewport"><meta content="webkit" name="renderer"><meta content="webkit" name="force-rendering"><meta content="✨小透明・宸✨" name="author"><meta content="" name="keywords"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><link href="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/favicon.png" rel="icon shortcut" type="image/ico"><link href="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/favicon.png" rel="icon"><link href="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/favicon.png" rel="apple-touch-icon"><link href="/atom.xml" rel="alternate" type="application/atom+xml"><title>Hashids 算法和实现原理介绍 | 存在感消失的地方|ω•`)</title><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://akarin.dev/2021/02/26/hashids-description/"},"headline":"Hashids 算法和实现原理介绍","datePublished":"2021-02-26T08:22:56.000Z","dateModified":"2021-02-26T08:22:56.000Z","author":{"@type":"Person","name":"✨小透明・宸✨","image":{"@type":"ImageObject","url":"https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/avatar.jpg"},"description":"身处寒夜 把握星光✨"},"publisher":{"@type":"Organization","name":"存在感消失的地方|ω•`)","logo":"https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/favicon.png"},"keywords":"","description":"虽然名字里写着 hash，实际上更像是一种多表代替的古典密码算法。"}</script><meta content="存在感消失的地方|ω•`)" property="og:site_name"><meta content="Hashids 算法和实现原理介绍" property="og:title"><meta content="虽然名字里写着 hash，实际上更像是一种多表代替的古典密码算法。" property="og:description"><meta content="article" property="og:type"><meta content="https://akarin.dev/2021/02/26/hashids-description/" property="og:url"><meta content="https://p.sda1.dev/12/95dcdb1428e5cd07b0065421c122ceea/yWMuo2Fk.jpg" property="og:image"><meta content="2021-02-26T08:22:56.000Z" property="article:published_time"><meta content="2021-02-26T08:22:56.000Z" property="article:modified_time"><meta content="✨小透明・宸✨" property="article:author"><script>document.documentMode&&(location.href="../../../../upgrade-browser.html")</script><script>document.addEventListener("WeixinJSBridgeReady",(()=>{const e=document.createElement("script");e.src="https://fastly.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/js/fuck-wechat.min.js",document.body.appendChild(e)}))</script><link href="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/css/mdui.min.css" rel="stylesheet"><link href="https://gcore.jsdelivr.net/combine/npm/prismjs@1/plugins/line-numbers/prism-line-numbers.min.css,npm/prism-themes@1/themes/prism-vsc-dark-plus.min.css,npm/aplayer@1/dist/APlayer.min.css,gh/TransparentLC/transparentlc.github.io@879beec/css/style.min.css" rel="stylesheet"><style>*{--sidebar-image:url(https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/sidebar_header.jpg);--sidebar-image-color:#958981;--banner-image:url(https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/daily_pic.png);--banner-image-color:#f09ea3;--post-thumbnail-color:#f09ea3;--copy-code-btn-color:#fff}.MathJax[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}</style><meta content="Hexo 7.0.0" name="generator"></head><body class="mdui-drawer-body-left mdui-theme-accent-pink mdui-theme-primary-pink"><script>window.switchDark=t=>{const a={auto:"mdui-theme-layout-auto",enable:"mdui-theme-layout-dark",disable:""};(t=t||localStorage.getItem("dark"))in a||(t="auto");for(const e in a)a[e]&&document.body.classList[e===t?"add":"remove"](a[e]);localStorage.setItem("dark",t)},switchDark()</script><button class="mdui-fab mdui-m-a-2 mdui-shadow-0 mdui-text-color-grey-700" mdui-drawer="{target:'#akarin-drawer'}" style="position:fixed;z-index:1"><i class="material-icons mdui-icon">menu</i></button><nav class="mdui-drawer mdui-drawer-full-height mdui-shadow-6" id="akarin-drawer"><div class="akarin-util-bg-cover mdui-p-x-2" id="akarin-drawer-media"><img class="akarin-hover-spin mdui-img-circle mdui-m-t-4" src="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/avatar.jpg" id="akarin-drawer-avatar"><div class="akarin-util-text-gradient mdui-card-media-covered"><div class="mdui-card-primary"><div class="mdui-typo-subheading">✨小透明・宸✨</div><div class="akarin-util-opacity-half mdui-typo-caption">存在感消失的地方|ω•`)</div></div></div></div><div class="mdui-list" mdui-collapse><div><a href="../../../../" class="mdui-ripple mdui-list-item"><i class="material-icons mdui-icon mdui-list-item-icon">home</i> <span class="mdui-list-item-content">主页</span></a></div><div><a href="../../../../about/" class="mdui-ripple mdui-list-item"><i class="material-icons mdui-icon mdui-list-item-icon">person</i> <span class="mdui-list-item-content">关于</span></a></div><div><a href="../../../../friend/" class="mdui-ripple mdui-list-item"><i class="material-icons mdui-icon mdui-list-item-icon">link</i> <span class="mdui-list-item-content">友链</span></a></div><div><a href="https://github.com/TransparentLC" target="_blank" rel="noopener" class="mdui-ripple mdui-list-item"><i class="material-icons mdui-icon mdui-list-item-icon">code</i> <span class="mdui-list-item-content">GitHub</span></a></div><div><a href="../../../../archives/" class="mdui-ripple mdui-list-item"><i class="material-icons mdui-icon mdui-list-item-icon">collections_bookmark</i> <span class="mdui-list-item-content">归档</span> <small class="akarin-drawer-badge mdui-color-theme-accent">33</small></a></div><div><a href="../../../../atom.xml" class="mdui-ripple mdui-list-item"><i class="material-icons mdui-icon mdui-list-item-icon">rss_feed</i> <span class="mdui-list-item-content">RSS</span></a></div><div class="mdui-divider"></div><div class="mdui-collapse-item mdui-collapse-item-open"><div class="mdui-ripple mdui-list-item mdui-collapse-item-header"><i class="material-icons mdui-icon mdui-list-item-icon">brightness_4</i> <span class="mdui-list-item-content">深色模式</span> <i class="material-icons mdui-icon mdui-collapse-item-arrow">keyboard_arrow_down</i></div><div class="mdui-list mdui-collapse-item-body"><div class="mdui-ripple mdui-list-item" data-dark="auto"><span class="mdui-list-item-content">根据系统主题切换</span></div><div class="mdui-ripple mdui-list-item" data-dark="enable"><span class="mdui-list-item-content">启用</span></div><div class="mdui-ripple mdui-list-item" data-dark="disable"><span class="mdui-list-item-content">禁用</span></div></div></div><div class="mdui-collapse-item mdui-collapse-item-open"><div class="mdui-ripple mdui-list-item mdui-collapse-item-header"><i class="material-icons mdui-icon mdui-list-item-icon">insert_chart</i> <span class="mdui-list-item-content">访问统计</span> <i class="material-icons mdui-icon mdui-collapse-item-arrow">keyboard_arrow_down</i></div><div class="mdui-list mdui-collapse-item-body"><div class="mdui-ripple mdui-list-item"><span class="mdui-list-item-content">站点访问量</span> <small class="akarin-drawer-badge mdui-color-theme-accent" id="busuanzi_value_site_pv">Loading</small></div><div class="mdui-ripple mdui-list-item"><span class="mdui-list-item-content">站点访客数</span> <small class="akarin-drawer-badge mdui-color-theme-accent" id="busuanzi_value_site_uv">Loading</small></div><div class="mdui-ripple mdui-list-item"><span class="mdui-list-item-content">页面访问量</span> <small class="akarin-drawer-badge mdui-color-theme-accent" id="busuanzi_value_page_pv">Loading</small></div></div></div></div></nav><picture id="akarin-top" title="返回顶部"><source srcset="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/top.avif" type="image/avif"><source srcset="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/top.webp" type="image/webp"><img src="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/top.png"></picture><div style="padding-top:20px"></div><div class="mdui-hidden-sm-down" style="padding-top:40px"></div><div class="mdui-hidden-md-down" style="padding-top:40px"></div><main class="mdui-container" style="max-width:1024px"><div class="akarin-util-rounded-5 mdui-card mdui-shadow-4"><div class="mdui-ripple akarin-post-bg akarin-util-bg-cover" data-src="https://p.sda1.dev/12/95dcdb1428e5cd07b0065421c122ceea/yWMuo2Fk.jpg" data-src-avif="https://vfile.meituan.net/mmdb/e634cc960d4e60a0dc8f352f2e9665fe60995.jpg" data-src-webp="https://p.sda1.dev/12/f6759ffa46f7485fd6c09947c05a90ed/yBa9aX5e.webp"><div class="akarin-blurred akarin-post-bg akarin-util-bg-cover" style="background-image:url(data:image/jpeg;base64,/9j/2wBDAAgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/2wBDAQgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/wAARCAAoAEADASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAABQYAAwQHAgH/xAArEAACAQQCAQMFAAEFAAAAAAABAgMABAUREiETBjFRFCJBQoEVMmFicZH/xAAYAQADAQEAAAAAAAAAAAAAAAACAwQBAP/EACMRAAICAgEEAgMAAAAAAAAAAAECABEDIRIEIjFRMqFBQpH/2gAMAwEAAhEDEQA/AO/s6L/qYD/s18kvtXMUUURkUjbOPZaUs7kbaLL+C5B8cFm0yofZz+zn54j2FCMb6t/yISK1gktl2ODHTcweutAAGgyOES9k+oaIWNCdEuZ3j4oiMS37AdCvMVwRBLybtR1S2l3kOFxI0wjWNdycyGAPsR7/AIoZLLc45rpsjeeaF32oVdAD3AFbicZEBAo+ovICjEeaFy7ET5TJXV6Xu0W3jYeFEjKsjLsbJahk+Qvk5xGS4jjViuy7Dn8ux30K32GMnxsNl9Nk3ghii5ywlAwfzdgq5+KzGQyzi7uD5wx8bqqaT+j5733RDKmJxzs6PiNTp+ZLhdjQs6hOK+nsrBLQEqHXcbH4I/G62WWasYEuTao7R8eS8utso0wLGsb5GOeRoJIGjVAFLP8AaOa7YFG/atUKWUDW5RBpjyfXsiONEnl8E0Wc5DZHaX/gkzjjRHn3MHqbBn1EyRTScFVT4taJR6BWWFyGL+lsY3jnsoZneV2QI+yh+DT5lHkxthPesV1CFYgn3G9N/SKVMLnVvZ5bq45hWEgiXgSEVD3ul5OJoUNxqFlAJJABhKKK2V54HhC8zyPElh2ejrQA7FYbrhdwfRK3QIAZiNKy9L7/AJ3qrvH9RPbkxP41j2HXalwCTrX9qq9s4Mra/RxosULFXUr9r7HfIt2d1MMBbIHXS4+41qzKA143tSWYULH6xfyKZGZ7DGW2Zi8cp0VjbUsQQAgHvYUVZ6Usco9xdW1zeP4YEJjU9k8yQG/9WrUw0UvPH3kXLwlpUdpNOwZuQUlfeilgzYy03FFyM0iqwPbM3fdXOECbI3R8fdzUZ+IA+V1DEWP+/wAbu5VWLAbPsfzqvcUKtLLDI48gjkVPt+4qx/nfVLuQy15cXHBy1sIuChgOyzN0DuieHulkvJUW5Nw8amG5RO3DL32Oho7IFLXLzVlX3o1+ZP1GIIEJYEk0QN1Cfrazub3BTW9rA8szsoUKob+kGkD0lg81i81aHITzoJ4ZFCN2rBAo4/8AGpUrZ1mqvU6hfWkwgnaLYKrzQg/lfxqlHDZu3yNxdsYHS6gAJtnGj3+3xxqVKJTsrQrX3F8iuTR8rKrq0nnvfO6PyRSmwpcK7dbBWnHGW87WEcctugIAG3G98fY1KlUZm7FFDVVGc2YbgHKxX0/qTE46KLdtwM90zpuMop6Vf96ZUxdhBkGv4IRHM0Phcr0HUHY2PyRUqVPQUADVizBAFmf/2Q)"></div><div class="akarin-util-text-gradient akarin-post-title"><div class="mdui-card-primary"><div class="mdui-card-primary-title mdui-text-color-white-text">Hashids 算法和实现原理介绍</div></div></div></div><div class="mdui-valign mdui-card-header"><div><img class="akarin-hover-spin mdui-card-header-avatar" src="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/img/avatar.jpg"><div class="mdui-card-header-title">✨小透明・宸✨</div><div class="mdui-card-header-subtitle">2021-02-26 16:22:56</div></div></div><article class="mdui-p-a-3 mdui-card-content mdui-typo"><p>Hashids 是一个小巧的开源库，几乎所有的编程语言都有相应的实现，可以将一个或多个非负整数编码成看上去比较随机的短字符串。按照<a href="https://hashids.org/" target="_blank" rel="noopener">官网</a>上的例子，<code>347</code> 可以编码成 <code>yr8</code>，<code>[27, 986]</code> 可以编码成 <code>3kTMd</code>，编码结果会根据初始化时的设置而不同，但只要<strong>保持设置相同</strong>就可以将编码后的字符串<strong>解码恢复成原来的数值</strong>。</p><p>这类算法一般可以用在数据库的自增 ID 上，如果需要把它写在 URL 或者 API 请求之类的地方展示出来但又不想轻易地被爬虫爬一遍的话……</p><p>例如以前屑站使用 AV 号对视频进行编号，实际上也是一个自增 ID，于是写个请求 <code>http://acg.tv/av{i}</code> 的爬虫，然后将 <code>i</code> 的值设为 0、1、2……如此一直爬下去，就可以获取到屑站所有视频的数据。后来屑站实装了 BV 号，av170001 变成了 BV17x411W7Kc，一时看不出规律，写爬虫就不怎么方便了。这个 BV 号就是对 AV 号使用 Hashids 类算法编码的结果。</p><p><em>不过 BV 号实装后没多久就有人翻出了 <a href="https://www.zhihu.com/question/381784377/answer/1099438784" target="_blank" rel="noopener">AV 号和 BV 号互转的算法</a>，并且 AV 号仍然可以照常使用，所以折腾出 BV 号这东西的意义嘛……另外 av99999999 之后的视频的 AV 号就<strong>不再自增</strong>而是<strong>随机生成</strong>了，真正起到反爬虫作用的其实是这个才对。</em></p><p>又比如你写了一个论坛，帖子的 ID 一般就是自增的。直接将自增 ID 展示出来的话，所有人都可以很容易地算出这个论坛每天发了多少帖子，由此继续分析用户活跃程度之类的……就像下面这样，注意写着 No. 的地方：</p><figure class="akarin-blurred-container"><div style="padding-bottom:min(calc(100%/1637*758),758px,480px)"></div><img class="mdui-hoverable mdui-img-rounded" data-src="https://p.sda1.dev/12/9100ab9c46b45700cc9159334ec85ce4/ut-Q4J-V.png" data-src-avif="https://vfile.meituan.net/mmdb/aa3f214a61541fc3f703bc57bf524b8f99487.jpg" data-src-webp="https://p.sda1.dev/12/d96e21c28417a0952f5a4537eacc3bce/Q6bE2pMp.webp"> <img class="mdui-hoverable mdui-img-rounded akarin-blurred" src="data:image/jpeg;base64,/9j/2wBDAAgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/2wBDAQgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/wAARCAAPACADASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAwQCBQYH/8QAKBAAAQQBAQUJAAAAAAAAAAAAAQACAxEEQRIhMTJhExRDcXKhsdHh/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAP/xAAaEQEAAwEBAQAAAAAAAAAAAAABAAIRAzFh/9oADAMBAAIRAxEAPwDsb8qFk0guMiyN76Q++xVYdDVHxP1I5FmaT1O+SlWg1rwdr5ocaoOsPV3wl+3KiItz2M67e72KO3Jh223OyrrmP2s4QVLHB7Yceca9QoNcFl7AC/J//9k"><noscript><img class="mdui-hoverable mdui-img-rounded mdui-center mdui-img-fluid" src="https://p.sda1.dev/12/9100ab9c46b45700cc9159334ec85ce4/ut-Q4J-V.png" alt="undefined" title="undefined"></noscript></figure><p><em>A 岛默许了这个统计，而且使用自增 ID 的串号表示回复和引用本身就是 A 岛社区文化的重要一部分，<del>比叔叔把已是屑站象征之一的 AV 号雪藏掉不知道高到哪里去了</del>。当然对这个串号使用爬虫（又称“爬岛”）还是不允许的。</em></p><p>Hashids 可以自定义编码时用到的字符表（默认是大小写字母数字，但是使用任意 Unicode 字符例如汉字和 emoji 也是可以的），还可以设置编码后字符串的最小长度（默认不设置，设置后编码得到的字符串长度小于此值则会用一定方式填充），另外还有叫 salt 的设定，设置不同的 salt 也会影响编码结果（就像加盐的 hash 算法那样？！）。可以在<a href="https://jsbin.com/kebobahude/edit?html,js,console" target="_blank" rel="noopener">这里</a>随意尝试～</p><h1 id="Hashids-真的属于-hash-算法吗？"><a href="#Hashids-真的属于-hash-算法吗？" class="headerlink" title="Hashids 真的属于 hash 算法吗？"></a>Hashids 真的属于 hash 算法吗？</h1><p>虽然 Hashids 的名字里面就写着 hash，而且设置里也用上了 salt 这种确实和 hash 算法有关的词，但是它真的是一个 hash 算法吗……找出 hash 算法的定义来对比一下：</p><ul><li>给定原始数据，很容易可以计算出对应的 hash 值。显然成立。</li><li>即使原始数据出现很小的差异，对应的 hash 值也会有巨大的变化，尽量不要产生碰撞。在上面的“随意尝试”里就可以看出确实会产生巨大变化（虽然某些地方的变化并不大……），而且按照 Hashids 的原理（稍后说明）冲突是完全不可能产生的。</li><li>给定 hash 值，反过来计算原始数据是很难的。嗯？Hashids 编码得到的字符串是可以恢复的啊？</li></ul><p>最后一条定义说明了 Hashids 实际上并不是一个严格意义上的 hash 算法。虽然各种真正的 hash 算法（例如 <a href="https://zh.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">bcrypt</a> 或者各种 <a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81" target="_blank" rel="noopener">HMAC</a>）都有 salt 的设定，但是就算知道了 salt 也很难恢复出原始数据，而 Hashids 的这个 salt 嘛……完全相反，所以它起到的更像是加密算法中密钥的作用。</p><p>实际上 Hashids 是使用进制转换的方式对数值进行编码的，将一般的数转换为十进制是固定使用数字 <code>0-9</code>，十六进制是数字 <code>0-9a-f</code>，而 Hashids 要转换到几进制和设置的字符表的长度有关，<strong>对每个数的每一位使用的“数字”是根据输入数值和设置的 salt 按照一些规则打乱字符表得到的</strong>，所以 Hashids 更像是一种多表代换密码，就像维吉尼亚密码那样，虽然每个字符都使用简单的凯撒密码加密，但是 offset 不同，于是攻击难度稍微提高了。</p><p>就算是在这里把 Hashids 当成加密算法，它的强度也不算太高，绝对不是密码学上安全的算法，所以<strong>严禁将 Hashids 用于加密机密数据，更不要真的像使用 hash 算法一样把它用于保存密码。</strong>按照<a href="https://carnage.github.io/2015/08/cryptanalysis-of-hashids" target="_blank" rel="noopener">这里</a>的分析，在使用选择明文攻击、字符表等设置使用默认值但不知道 salt 的情况下，通过解一组方程分析 salt 的前三个字符有大概 200 种可能，这个数量已经大大低于暴力破解需要尝试的次数了。</p><p>为什么设计这个算法的人选用了 hash 和 salt 之类的名词？按照<a href="https://hashids.org/#why-hashids" target="_blank" rel="noopener">官网上的说明</a>，因为对一般人来说，它看起来像 hash，走路像 hash，叫声像 hash，那么它就是……⊂彡☆))д`)</p><blockquote><p>Why “hashids”?</p><p>Originally the project <strong>referred to generated ids as hashes, and obviously the name hashids has the word hash in it</strong>. Technically, these generated ids cannot be called hashes since a cryptographic hash has one-way mapping (cannot be decrypted).</p><p>However, when people search for a solution, like a “youtube hash” or “bitly short id”, they usually <strong>don’t really care of the technical details</strong>. So hashids stuck as a term — an algorithm to obfuscate numbers.</p></blockquote><figure class="akarin-blurred-container"><div style="padding-bottom:min(calc(100%/664*493),493px,480px)"></div><img class="mdui-hoverable mdui-img-rounded" data-src="https://p.sda1.dev/12/2ba066d73298f9705dbaeb08ca4bcc89/mRAQGV5H.jpg" data-src-avif="https://vfile.meituan.net/mmdb/d634d60ebe06feb4793ba06f3c7e91076047.jpg" data-src-webp="https://p.sda1.dev/12/c7f2390a9afd1ddc0c3231deed88a5f9/XSpAU-lx.jpg"> <img class="mdui-hoverable mdui-img-rounded akarin-blurred" src="data:image/jpeg;base64,/9j/2wBDAAgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/2wBDAQgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/wAARCAAYACADASIAAhEBAxEB/8QAGgAAAgIDAAAAAAAAAAAAAAAAAAYBBQMEB//EACYQAAICAgEDAwUBAAAAAAAAAAECAxEEBQASIjEjQVEGFTJSgpH/xAAYAQACAwAAAAAAAAAAAAAAAAAEBQECA//EAB0RAAIDAAIDAAAAAAAAAAAAAAECAAMRBCExQVH/2gAMAwEAAhEDEQA/AO7EhQSSAB5J4n7fYbGTMxRr8lI4Im6pSRZkP618cv5gczPbDsiKGNZJj+xckKg/yzzSbGuaOCfWSh+0deNbwsSV9yBXk+fjhFDUIdsBJ+ehMbRawxMEmbeKsDNFjF5fZCwUH+uJSfXm2g2kWNm62BIndVI7romrDcbM/CWHFxZxBJC0lhopCCyn+SRxU22LBPjdUiW0bKyH3BvjCqjivWXVOjvmDPbcrhWMfZcyfC2eYItTlzCaSEFgvp0FrqBA4QbbMkPdpctPSLmwbFNVfjRJ4cOJ4fMmRsHmZsaTSZbJZp+k0aNDlTGBkbPAX7FmwouS4ZyOylU0XseDfDhywdwMDECQVUnSBP/Z"><noscript><img class="mdui-hoverable mdui-img-rounded mdui-center mdui-img-fluid" src="https://p.sda1.dev/12/2ba066d73298f9705dbaeb08ca4bcc89/mRAQGV5H.jpg" alt="undefined" title="undefined"></noscript></figure><hr><p>从这里开始就是介绍 Hashids 的比较详细的实现细节了。在此之前我 Google 了一下介绍 Hashids 的文章，基本上都是简单介绍一下它的主要用途是混淆自增 ID，然后就是一大堆复制粘贴的用法示例了，偶尔有几篇提到了“进制转换”不过也并不是很详细……所以接下来我会参考 <a href="https://github.com/niieani/hashids.js/blob/master/lib/hashids.ts" target="_blank" rel="noopener">TypeScript/JavaScript 版实现的源码</a>详细介绍一下编码和解码的原理（其它语言的实现应该也是类似的）。</p><p>如果只是想要简单了解 Hashids 原理的话，可以直接阅读<a href="https://hashids.org/#how-does-it-work" target="_blank" rel="noopener">官网上的介绍</a>，简略介绍了进制转换等各种涉及到的步骤。想要了解更多细节的话就继续往下翻吧～</p><hr><h1 id="算法的初始化"><a href="#算法的初始化" class="headerlink" title="算法的初始化"></a>算法的初始化</h1><p>所有的编码和解码都是使用同一个 Hashids 对象的实例，在创建这个实例时进行算法的初始化，一般情况下需要输入以下参数：</p><ul><li>salt：一个可以包含任意字符的字符串，对之后打乱字符表的结果有影响。默认是留空。</li><li>minLength：最小长度，编码得到的字符串长度小于此值则会用一定方式填充。默认是留空。</li><li>alphabet：初始字符表，不能有重复字符，编码结果只可能含有这里的字符，即使字符相同顺序不同也会改变结果，长度至少为 16。默认是 <code>a-zA-Z1234567890</code> 一共 62 个字符。</li><li>seps：编码中用于分隔各个数值的字符（稍后说明 x2），必须是 alphabet 的子集，但是不要求字符不重复，顺序也会影响结果。默认是 <code>cfhistuCFHISTU</code>，原作者的想法是使用这些字母做分隔符可以<a href="https://hashids.org/#cursing" target="_blank" rel="noopener">避免编码结果中出现粗鄙之语</a>。</li></ul><p><em>实际上 JS 版实现会<a href="https://github.com/niieani/hashids.js/blob/f8a2d2f6bbd4ecbe0ec1b0a2aa04a6cbc7048098/lib/hashids.ts#L50" target="_blank" rel="noopener">自动处理</a>字符表去重、“不能重复”和“子集”之类的要求。</em></p><p>初始化以后就可以进行编码了。</p><pre class="language-javascript line-numbers" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> hashids <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashids</span><span class="token punctuation">(</span>
    <span class="token comment">// salt</span>
    <span class="token string">'@salt!'</span><span class="token punctuation">,</span>
    <span class="token comment">// minLength</span>
    <span class="token number">24</span><span class="token punctuation">,</span>
    <span class="token comment">// alphabet: use default</span>
    <span class="token keyword">undefined</span><span class="token punctuation">,</span>
    <span class="token comment">// seps</span>
    <span class="token string">'SEPS'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hashids<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token number">114514</span><span class="token punctuation">,</span> <span class="token number">1919810</span><span class="token punctuation">,</span> <span class="token number">893</span><span class="token punctuation">,</span> <span class="token number">931</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// tY8p8oMWMb76xOS3Jh4uvs2x</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hashids<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token string">'tY8p8oMWMb76xOS3Jh4uvs2x'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [114514, 1919810, 893, 931]</span><span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编码后的字符串，看上去是一堆没什么规律的字母数字，实际上可以分成几个部分。例如上面得到的字符串 <span style="color:#e77">tY8</span><span style="color:#63b">p</span><span style="color:#f80">8</span><span style="color:#9c6">oMWM</span><span style="color:#273">b</span><span style="color:#9c6">76xO</span><span style="color:#273">S</span><span style="color:#9c6">3J</span><span style="color:#273">h</span><span style="color:#9c6">4u</span><span style="color:#63b">v</span><span style="color:#e77">s2x</span> 就可以分为用不同颜色表示的以下部分：</p><ul><li><span style="color:#9c6">单个数值编码后的值</span></li><li><span style="color:#273">seperator，也就是不同数值之间的分隔符</span></li><li><span style="color:#f80">lottery，用于在编码过程中打乱字符表</span></li><li><span style="color:#63b">guard，用于分隔编码部分和填充部分</span></li><li><span style="color:#e77">编码后字符串左右两边的填充</span></li></ul><p>前三个是实际的编码部分，后两个用于填充，只有设置了最小长度的情况下才有可能出现在编码结果中。</p><p>Hashids 算法中经常需要打乱字符串中的字符，使用的都是下面这个<a href="https://github.com/niieani/hashids.js/blob/f8a2d2f6bbd4ecbe0ec1b0a2aa04a6cbc7048098/lib/hashids.ts#L302" target="_blank" rel="noopener">稍有修改的 Fisher–Yates Shuffle 洗牌算法</a>，除了要打乱的字符串（拆成了包含所有字符的数组）这里还有另一个参数也叫 salt（留空则直接原样返回不打乱），只要字符串和 salt 相同就可以保证打乱结果相同……所以这个 salt 起的明明是随机数生成器中种子的作用吧！(╯‵□′)╯︵┻━┻ <strong>为了不与一开始输入的 salt 混淆，之后就用 seed 表示打乱时的这个 salt 参数好了。</strong></p><pre class="language-javascript line-numbers" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token parameter">alphabetChars<span class="token punctuation">,</span> saltChars</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>saltChars<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> alphabetChars<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> integer<span class="token punctuation">;</span>
    <span class="token keyword">const</span> transformed <span class="token operator">=</span> alphabetChars<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> transformed<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在原始的Fisher-Yates Shuffled里，j是0-i范围的一个随机数</span>
        v <span class="token operator">%=</span> saltChars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        p <span class="token operator">+=</span> integer <span class="token operator">=</span> saltChars<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>integer <span class="token operator">+</span> v <span class="token operator">+</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> i<span class="token punctuation">;</span>
        v<span class="token operator">++</span><span class="token punctuation">;</span>

        <span class="token punctuation">[</span>transformed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> transformed<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>transformed<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> transformed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> transformed<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子里，一开始的时候输入了 <code>SEPS</code> 四个字符作为 seps，先从输入的字符表中去掉这几个字符（没有了 E、P、S 这三个大写字母，此时还剩下 <code>62 - 3 = 59</code> 个字符），然后以 salt 作为 seed 将 seps 打乱一次，打乱结果为 <code>SSEP</code>。但是上面的编码结果中还出现了这些字符之外的 seperator（b 和 h），这是因为 Hashids 要求 seps 的字符数量必须不少于字符表长度的 1/3.5（向上取整），所以这里需要 <code>Math.ceil(59 / 3.5) = 17</code> 个字符作为 seps，不足的 13 个字符从字符表的前几个字符中取出来，接到 seps 后面补充数量。</p><p>补充之后，最后的 seps 字符列表就是 <code>SSEPabcdefghijklm</code>（后面的 <code>a-m</code> 是从字符表中取出的），字符表是 <code>nopqrstuvwxyzABCDFGHIJKLMNOQRTUVWXYZ1234567890</code>（前面的 <code>a-m</code> 被取走了，还有 <code>59 - 13 - 46</code> 个字符）。</p><p>如果设置了编码后字符串的最小长度的话，编码后可能会需要进行填充。Hashids 通过在实际的编码部分左右各放置一个 guard 字符的方式将编码部分和填充部分分开。guards 也是从字符表中取出的，并不能手动设置，字符数量是字符表长度的 1/12（向上取整）。在这里就需要取出 <code>Math.ceil(46 / 12) = 4</code> 个字符。</p><p>先以 salt 作为 seed 将当前的字符表打乱一次，字符表变成了 <code>vpnz0xJYw6Q1TLNqH8WGuRB5ZMKOAroCFtD74IU2ysX9V3</code>，然后取出字符表的前 4 个字符 <code>vpnz</code> 作为 guards，字符表中剩下 <code>0xJYw6Q1TLNqH8WGuRB5ZMKOAroCFtD74IU2ysX9V3</code> 一共 42 个字符，这些字符会出现在编码结果的除 seperator 和 guard 以外的所有部分中。</p><p>最后用一个流程图来概括以上的初始化过程：</p><figure class="akarin-blurred-container"><div style="padding-bottom:min(calc(100%/961*301),301px,480px)"></div><img class="mdui-hoverable mdui-img-rounded" data-src="https://svgshare.com/i/aFA.svg"> <img class="mdui-hoverable mdui-img-rounded akarin-blurred" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAKBAMAAAAnY0GXAAAAMFBMVEX////6+fj1+Pi04PUdouP0ttfK4rHJ6fibyWx3xuxtsCrj8NZAsefZBXbnYqngM48tZA+eAAAAA3RSTlP//vftCFu/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVR42mNQYEACTIJCDALIAowZSWgCHUoMioJAISaoMCMDE4PqfQETZyCb04XBxJ2xK4lBNUhA2QgowG7MoGzEmMbEoBAKErApAAoAtWzbxKB6D6iF2eUQUAtQYNUmiKEMmhBTGYHuUIAaD3MaAF2qD29a1slhAAAAAElFTkSuQmCC"><noscript><img class="mdui-hoverable mdui-img-rounded mdui-center mdui-img-fluid" src="https://svgshare.com/i/aFA.svg" alt="undefined" title="undefined"></noscript></figure><h1 id="对输入的数进行编码"><a href="#对输入的数进行编码" class="headerlink" title="对输入的数进行编码"></a>对输入的数进行编码</h1><p>初始化以后就可以将输入的整数编码了，编码期间使用的字符表 alphabet 是从初始化后的 Hashids 对象里复制的，虽然会涉及多次打乱字符表的操作但是并不会改变原对象的字符表，解码的时候也是一样的。</p><p>可能是为了添加更多的随机性，Hashids 算法在编码过程中设置了一个称为 lottery 的字符。对于每个输入的第 a 个数 b（a 是从 0 开始计数的），计算 <code>b % (100 + a)</code> 的和（记为 numbersIdInt，后面还会用到），则 <code>alphabet[numbersIdInt % alphabet.length]</code> 就是 lottery 字符。</p><p>在上面的例子中，初始化以后的 alphabet 是 <code>0xJYw6Q1TLNqH8WGuRB5ZMKOAroCFtD74IU2ysX9V3</code>，对 <code>[114514, 1919810, 893, 931]</code> 编码得到的 lottery 是 8 也就是 <code>alphabet[13]</code>，是根据以下过程算出的：</p><ul><li><code>114514 % 100 = 14</code></li><li><code>1919810 % 101 = 2</code></li><li><code>893 % 102 = 77</code></li><li><code>931 % 103 = 4</code></li><li><code>numbersIdInt = 14 + 2 + 77 + 4 = 97</code></li><li><code>lotteryIndex = 97 % 42 = 13</code></li></ul><p>然后就是对每个数编码了。前面提过 Hashids 的编码原理是进制转换，现在 alphabet 有 42 个字符，相当于将各个数转换为 42 进制。Hashids 又有多表代换的特征，表现在编码每个数之前 alphabet 都会使用 <code>lottery + salt + alphabet</code> 作为 seed 被打乱一次（取代之前的 alphabet），于是每个数在进制转换时使用的“数字”都是不一样的。</p><p>如果编码的不是最后一个数，编码后还要添加一个 seperator，计算方法是：对于第 a 个数 b，编码后的第一个字符的 Unicode 码点是 c，则需要添加的 seperator 是 <code>seps[a % (b + c) % seps.length]</code>。</p><p>例如，上面的例子中编码的过程：</p><ul><li>使用 seed <code>8@salt!0xJYw6Q1TLNqH8WGuRB5ZMKOAroCFtD74IU2ysX9V3</code> 打乱字符表得到 <code>8ouNLs4OK5V9wA613QqG7XMYZ0JRTFy2BCHItUWxrD</code></li><li>进制转换的结果是 <code>114514 = 1 * 42 ** 3 + 22 * 42 ** 2 + 38 * 42 ** 1 + 22 * 40 ** 0</code></li><li>转换后的各位数 <code>1 22 38 22</code> 在字符表中对应的字符分别是 oMWM</li><li><code>"o" = String.fromCodePoint(111)</code>，所以添加 seperator：<code>seps[114514 % (0 + 111) % 17] = seps[73 % 17] = seps[5]</code> 也就是 b</li><li>使用 seed <code>8@salt!8ouNLs4OK5V9wA613QqG7XMYZ0JRTFy2BCHItUWxrD</code> 打乱字符表得到 <code>DWsUJ81NVrXqAxtYZ9wuIBG547K2RML3OQTCFH6o0y</code></li><li>进制转换的结果是 <code>1919810 = 25 * 42 ** 3 + 38 * 42 ** 2 + 13 * 42 ** 1 + 32 * 42 ** 0</code></li><li>转换后的各位数 <code>25 38 13 32</code> 在字符表中对应的字符分别是 76xO</li><li><code>"7" = String.fromCodePoint(55)</code>，所以添加 seperator：<code>seps[1919810 % (1 + 55) % 17] = seps[18 % 17] = seps[1]</code> 也就是 S</li><li>……</li></ul><p>最后可以得到未填充的编码部分 <span style="color:#f80">8</span><span style="color:#9c6">oMWM</span><span style="color:#273">b</span><span style="color:#9c6">76xO</span><span style="color:#273">S</span><span style="color:#9c6">3J</span><span style="color:#273">h</span><span style="color:#9c6">4u</span>。</p><h1 id="编码结果的填充"><a href="#编码结果的填充" class="headerlink" title="编码结果的填充"></a>编码结果的填充</h1><p>如果设置了最小长度，而刚刚得到的编码结果长度又不足，那么就需要进行填充了。Hashids 使用放在编码部分左右两边各一个的 guard 字符将编码和填充部分分开，这两个字符均使用 <code>guards[(numbersIdInt + x) % guards.length]</code> 求出，对于左边/右边的 guard，x 分别是编码部分第 0/1 个字符的 Unicode 码点。先添加左边的 guard，如果已经满足最小长度则不再添加右边的 guard。在上面的例子中：</p><ul><li>guards 是 vpnz</li><li>编码部分长度 16，前两个字符的 Unicode 码点：<code>"8" = String.fromCodePoint(56)</code> 和 <code>"o" = String.fromCodePoint(111)</code></li><li>设置了最小长度为 24，编码结果的长度不足，因此在左边添加 <code>guards[(97 + 56) % 4] = guards[1]</code> 也就是 p</li><li>长度仍然不足，因此在右边添加 <code>guards[(97 + 111) % 4] = guards[0]</code> 也就是 v</li></ul><p>如果添加 guard 之后长度还是不足呢？接下来就会在编码结果的左右两边填充数遍完整的字符表了。</p><ul><li>以 alphabet 自己作为 seed 打乱 alphabet（同样是取代之前的 alphabet）</li><li>将 alphabet 一分为二，前 <code>Math.floor(alphabet.length / 2)</code> 个字符添加到编码结果右边，剩下的字符添加到编码结果左边</li><li>循环到编码结果的长度超过最小长度为止</li><li>取编码结果 result 的从第 <code>Math.floor((result.length - minLength) / 2)</code> 个字符开始的 minLength 个字符作为最后的编码结果</li></ul><p>在上面的例子中，添加了 guard 的编码结果是 <span style="color:#63b">p</span><span style="color:#f80">8</span><span style="color:#9c6">oMWM</span><span style="color:#273">b</span><span style="color:#9c6">76xO</span><span style="color:#273">S</span><span style="color:#9c6">3J</span><span style="color:#273">h</span><span style="color:#9c6">4u</span><span style="color:#63b">v</span>，打乱一次 alphabet 的结果是 s2xC0oRZAQuLqyK6GwXUHNTB7rV4IOD51MF9WJ3tY8，添加到编码结果的左右两边得到 <span style="color:#e77">NTB7rV4IOD51MF9WJ3tY8</span><span style="color:#63b">p</span><span style="color:#f80">8</span><span style="color:#9c6">oMWM</span><span style="color:#273">b</span><span style="color:#9c6">76xO</span><span style="color:#273">S</span><span style="color:#9c6">3J</span><span style="color:#273">h</span><span style="color:#9c6">4u</span><span style="color:#63b">v</span><span style="color:#e77">s2xC0oRZAQuLqyK6GwXUH</span>，长度为 60，于是截取从第 <code>Math.floor((60 - 24) / 2) = 18</code> 个字符开始的 24 个字符，得到最后的编码结果 <span style="color:#e77">tY8</span><span style="color:#63b">p</span><span style="color:#f80">8</span><span style="color:#9c6">oMWM</span><span style="color:#273">b</span><span style="color:#9c6">76xO</span><span style="color:#273">S</span><span style="color:#9c6">3J</span><span style="color:#273">h</span><span style="color:#9c6">4u</span><span style="color:#63b">v</span><span style="color:#e77">s2x</span>。</p><h1 id="解码和校验"><a href="#解码和校验" class="headerlink" title="解码和校验"></a>解码和校验</h1><p>对 Hashids 的解码实际上是把字符串中表示每个数的字符串恢复回原来的数，因为 seps 和 guards 是固定的，lottery 又固定是 guard 之间的未填充的编码部分的第一个字符，所以很容易就可以把每个数的字符串从编码后的字符串里拆出来。按照同样的顺序，每解码一个数之前，先使用 <code>lottery + salt + alphabet</code> 打乱一次字符表，对照字符表得出这个数在 x 进制下的表示，再转换到十进制就可以完成解码了。</p><p>既然这样，那剩下的 seperator 和 guard 还有填充部分随便乱写，也是可以解码出结果的哦？</p><p>当然不能出这种问题啦！所以 Hashids 的<a href="https://github.com/niieani/hashids.js/blob/f8a2d2f6bbd4ecbe0ec1b0a2aa04a6cbc7048098/lib/hashids.ts#L275" target="_blank" rel="noopener">处理方法</a>是……<strong>把解码出的数重新编码一遍，如果和输入的字符串不同则按照解码结果无效处理，什么也不返回</strong>。</p><p>看来这些部分还起到了校验码的作用呢。</p><blockquote><p>封面图：<a href="https://www.pixiv.net/artworks/43737030" target="_blank" rel="noopener">Pixiv ID: 43737030 「Cafe de Lapin」 by Koi</a></p></blockquote><blockquote class="mdui-m-b-0 mdui-m-x-0 mdui-p-y-1" style="border-left:4px solid rgba(0,0,0,.36)"><strong>本作品采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。不允许内容农场类网站、CSDN 用户和微信公众号转载。</strong><br><strong>本文作者：✨小透明・宸✨</strong><br><strong>本文链接：<a href="https://akarin.dev/2021/02/26/hashids-description/">https://akarin.dev/2021/02/26/hashids-description/</a></strong></blockquote></article><div class="mdui-p-a-3 mdui-color-white" id="lv-container" data-id="city" data-uid="MTAyMC80NDUwOC8yMTAzOQ=="><script>(()=>{const e=document.createElement("script");e.src="https://cdn-city.livere.com/js/embed.dist.js",e.async=!0,document.body.appendChild(e)})()</script></div></div><div class="mdui-valign mdui-m-t-2"><a href="../../../09/16/a-taste-of-curve25519/" class="mdui-ripple mdui-btn mdui-btn-icon"><i class="material-icons mdui-icon">chevron_left</i> </a><span class="mdui-typo-body-1-opacity mdui-text-left mdui-m-l-1" title="RSA 算法的替代品：X25519/Ed25519 使用记录">上一篇</span> <span class="mdui-typo-body-1-opacity mdui-text-center" style="flex-grow:1"></span> <span class="mdui-typo-body-1-opacity mdui-text-right mdui-m-r-1" title="成语接龙的求解算法">下一篇</span> <a href="../../../01/28/idioms-solitaire/" class="mdui-ripple mdui-btn mdui-btn-icon"><i class="material-icons mdui-icon">chevron_right</i></a></div></main><footer class="mdui-container mdui-m-y-5 mdui-typo" style="display:flex;max-width:1024px"><div class="mdui-typo-body-1-opacity mdui-text-left">Copyright © 2024 ✨小透明・宸✨<br>Hosted by <a href="https://github.com/TransparentLC/transparentlc.github.io" target="_blank">Github Pages</a></div><div style="flex-grow:1"></div><div class="mdui-typo-body-1-opacity mdui-text-right">Powered by <a href="https://hexo.io" target="_blank">Hexo</a> <span class="mdui-hidden-xs-down">7.0.0</span><br>Theme - <a href="https://github.com/TransparentLC/hexo-theme-akarin" target="_blank">Akarin</a></div></footer><script src="https://gcore.jsdelivr.net/combine/gh/TransparentLC/transparentlc.github.io/js/mdui.min.js,npm/medium-zoom@1/dist/medium-zoom.min.js,npm/instant.page@5/instantpage.min.js,npm/aplayer@1/dist/APlayer.min.js,gh/TransparentLC/transparentlc.github.io@879beec/js/script.min.js"></script><script src="https://gcore.jsdelivr.net/gh/TransparentLC/transparentlc.github.io/js/bsz.min.js" async></script></body></html>